// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum Auth_WebAuthn_AttestationConveyancePreference: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Do not request attestation.
  ///  <https://www.w3.org/TR/webauthn/#dom-attestationconveyancepreference-none>
  case none_ = 0
  ///  Request attestation in a semi-anonymized form.
  ///  <https://www.w3.org/TR/webauthn/#dom-attestationconveyancepreference-indirect>
  case indirect_ = 1
  ///  Request attestation in a direct form.
  ///  <https://www.w3.org/TR/webauthn/#dom-attestationconveyancepreference-direct>
  case direct = 2

  public static var max: Auth_WebAuthn_AttestationConveyancePreference { return .direct }
  public static var min: Auth_WebAuthn_AttestationConveyancePreference { return .none_ }
}


public enum Auth_WebAuthn_AuthenticatorTransport: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  <https://www.w3.org/TR/webauthn/#dom-authenticatortransport-usb>
  case usb = 0
  ///  <https://www.w3.org/TR/webauthn/#dom-authenticatortransport-nfc>
  case nfc = 1
  ///  <https://www.w3.org/TR/webauthn/#dom-authenticatortransport-ble>
  case ble = 2
  ///  <https://www.w3.org/TR/webauthn/#dom-authenticatortransport-internal>
  case internal_ = 3
  ///  Hybrid transport, formerly caBLE. Part of the level 3 draft specification.
  ///  <https://w3c.github.io/webauthn/#dom-authenticatortransport-hybrid>
  case hybrid = 4
  ///  Test transport; used for Windows 10.
  case test = 5

  public static var max: Auth_WebAuthn_AuthenticatorTransport { return .test }
  public static var min: Auth_WebAuthn_AuthenticatorTransport { return .usb }
}


public enum Auth_WebAuthn_CredentialProtectionPolicy: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  This reflects "FIDO_2_0" semantics. In this configuration, performing
  ///  some form of user verification is optional with or without credentialID
  ///  list. This is the default state of the credential if the extension is
  ///  not specified.
  case userverificationoptional = 0
  ///  In this configuration, credential is discovered only when its
  ///  credentialID is provided by the platform or when some form of user
  ///  verification is performed.
  case userverificationoptionalwithcredentialidlist = 1
  ///  This reflects that discovery and usage of the credential MUST be
  ///  preceded by some form of user verification.
  case userverificationrequired = 2

  public static var max: Auth_WebAuthn_CredentialProtectionPolicy { return .userverificationrequired }
  public static var min: Auth_WebAuthn_CredentialProtectionPolicy { return .userverificationoptional }
}


public enum Auth_WebAuthn_AuthenticatorAttachment: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Request a device that is part of the machine aka inseperable.
  ///  <https://www.w3.org/TR/webauthn/#attachment>
  case platform = 0
  ///  Request a device that can be seperated from the machine aka an external token.
  ///  <https://www.w3.org/TR/webauthn/#attachment>
  case crossplatform = 1

  public static var max: Auth_WebAuthn_AuthenticatorAttachment { return .crossplatform }
  public static var min: Auth_WebAuthn_AuthenticatorAttachment { return .platform }
}


public enum Auth_WebAuthn_UserVerificationPolicy: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  <https://www.w3.org/TR/webauthn/#dom-userverificationrequirement-preferred>
  case preferred = 0
  ///  <https://www.w3.org/TR/webauthn/#dom-userverificationrequirement-required>
  case required_ = 1
  ///  <https://www.w3.org/TR/webauthn/#dom-userverificationrequirement-discouraged>
  case discouraged = 2

  public static var max: Auth_WebAuthn_UserVerificationPolicy { return .discouraged }
  public static var min: Auth_WebAuthn_UserVerificationPolicy { return .preferred }
}


public struct Auth_WebAuthn_CredentialCreationOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case rp = 4
    case user = 6
    case challenge = 8
    case pubKeyCredParams = 10
    case timeout = 12
    case attestation = 14
    case excludeCredentials = 16
    case authenticatorSelection = 18
    case extensions = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The relying party 
  public var rp: Auth_WebAuthn_RelyingParty? { let o = _accessor.offset(VTOFFSET.rp.v); return o == 0 ? nil : Auth_WebAuthn_RelyingParty(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The user.
  public var user: Auth_WebAuthn_User? { let o = _accessor.offset(VTOFFSET.user.v); return o == 0 ? nil : Auth_WebAuthn_User(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The one-time challenge for the credential to sign
  public var challenge: String? { let o = _accessor.offset(VTOFFSET.challenge.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var challengeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.challenge.v) }
  ///  The set of cryptographic types allowed by this server.
  public var hasPubKeyCredParams: Bool { let o = _accessor.offset(VTOFFSET.pubKeyCredParams.v); return o == 0 ? false : true }
  public var pubKeyCredParamsCount: Int32 { let o = _accessor.offset(VTOFFSET.pubKeyCredParams.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func pubKeyCredParams(at index: Int32) -> Auth_WebAuthn_PubKeyCredParams? { let o = _accessor.offset(VTOFFSET.pubKeyCredParams.v); return o == 0 ? nil : Auth_WebAuthn_PubKeyCredParams(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  The timeout for the authenticator to stop accepting the operation
  public var timeout: UInt32 { let o = _accessor.offset(VTOFFSET.timeout.v); return o == 0 ? 60000 : _accessor.readBuffer(of: UInt32.self, at: o) }
  @discardableResult public func mutate(timeout: UInt32) -> Bool {let o = _accessor.offset(VTOFFSET.timeout.v);  return _accessor.mutate(timeout, index: o) }
  ///  The requested attestation level from the device.
  public var attestation: Auth_WebAuthn_AttestationConveyancePreference { let o = _accessor.offset(VTOFFSET.attestation.v); return o == 0 ? .none_ : Auth_WebAuthn_AttestationConveyancePreference(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  @discardableResult public func mutate(attestation: Auth_WebAuthn_AttestationConveyancePreference) -> Bool {let o = _accessor.offset(VTOFFSET.attestation.v);  return _accessor.mutate(attestation.rawValue, index: o) }
  ///  The list of credentials that are excluded from this operation.
  public var hasExcludeCredentials: Bool { let o = _accessor.offset(VTOFFSET.excludeCredentials.v); return o == 0 ? false : true }
  public var excludeCredentialsCount: Int32 { let o = _accessor.offset(VTOFFSET.excludeCredentials.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func excludeCredentials(at index: Int32) -> Auth_WebAuthn_PublicKeyCredentialDescriptor? { let o = _accessor.offset(VTOFFSET.excludeCredentials.v); return o == 0 ? nil : Auth_WebAuthn_PublicKeyCredentialDescriptor(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  The list of authenticators that are allowed for this operation.
  public var authenticatorSelection: Auth_WebAuthn_AuthenticatorSelectionCriteria? { let o = _accessor.offset(VTOFFSET.authenticatorSelection.v); return o == 0 ? nil : Auth_WebAuthn_AuthenticatorSelectionCriteria(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  The extensions that are allowed for this operation.
  public var extensions: Auth_WebAuthn_RequestRegistrationExtensions? { let o = _accessor.offset(VTOFFSET.extensions.v); return o == 0 ? nil : Auth_WebAuthn_RequestRegistrationExtensions(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCredentialCreationOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(rp: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rp, at: VTOFFSET.rp.p) }
  public static func add(user: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: user, at: VTOFFSET.user.p) }
  public static func add(challenge: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: challenge, at: VTOFFSET.challenge.p) }
  public static func addVectorOf(pubKeyCredParams: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pubKeyCredParams, at: VTOFFSET.pubKeyCredParams.p) }
  public static func add(timeout: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timeout, def: 60000, at: VTOFFSET.timeout.p) }
  public static func add(attestation: Auth_WebAuthn_AttestationConveyancePreference, _ fbb: inout FlatBufferBuilder) { fbb.add(element: attestation.rawValue, def: 0, at: VTOFFSET.attestation.p) }
  public static func addVectorOf(excludeCredentials: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: excludeCredentials, at: VTOFFSET.excludeCredentials.p) }
  public static func add(authenticatorSelection: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: authenticatorSelection, at: VTOFFSET.authenticatorSelection.p) }
  public static func add(extensions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: extensions, at: VTOFFSET.extensions.p) }
  public static func endCredentialCreationOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCredentialCreationOptions(
    _ fbb: inout FlatBufferBuilder,
    rpOffset rp: Offset = Offset(),
    userOffset user: Offset = Offset(),
    challengeOffset challenge: Offset = Offset(),
    pubKeyCredParamsVectorOffset pubKeyCredParams: Offset = Offset(),
    timeout: UInt32 = 60000,
    attestation: Auth_WebAuthn_AttestationConveyancePreference = .none_,
    excludeCredentialsVectorOffset excludeCredentials: Offset = Offset(),
    authenticatorSelectionOffset authenticatorSelection: Offset = Offset(),
    extensionsOffset extensions: Offset = Offset()
  ) -> Offset {
    let __start = Auth_WebAuthn_CredentialCreationOptions.startCredentialCreationOptions(&fbb)
    Auth_WebAuthn_CredentialCreationOptions.add(rp: rp, &fbb)
    Auth_WebAuthn_CredentialCreationOptions.add(user: user, &fbb)
    Auth_WebAuthn_CredentialCreationOptions.add(challenge: challenge, &fbb)
    Auth_WebAuthn_CredentialCreationOptions.addVectorOf(pubKeyCredParams: pubKeyCredParams, &fbb)
    Auth_WebAuthn_CredentialCreationOptions.add(timeout: timeout, &fbb)
    Auth_WebAuthn_CredentialCreationOptions.add(attestation: attestation, &fbb)
    Auth_WebAuthn_CredentialCreationOptions.addVectorOf(excludeCredentials: excludeCredentials, &fbb)
    Auth_WebAuthn_CredentialCreationOptions.add(authenticatorSelection: authenticatorSelection, &fbb)
    Auth_WebAuthn_CredentialCreationOptions.add(extensions: extensions, &fbb)
    return Auth_WebAuthn_CredentialCreationOptions.endCredentialCreationOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.rp.p, fieldName: "rp", required: false, type: ForwardOffset<Auth_WebAuthn_RelyingParty>.self)
    try _v.visit(field: VTOFFSET.user.p, fieldName: "user", required: false, type: ForwardOffset<Auth_WebAuthn_User>.self)
    try _v.visit(field: VTOFFSET.challenge.p, fieldName: "challenge", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pubKeyCredParams.p, fieldName: "pubKeyCredParams", required: false, type: ForwardOffset<Vector<ForwardOffset<Auth_WebAuthn_PubKeyCredParams>, Auth_WebAuthn_PubKeyCredParams>>.self)
    try _v.visit(field: VTOFFSET.timeout.p, fieldName: "timeout", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.attestation.p, fieldName: "attestation", required: false, type: Auth_WebAuthn_AttestationConveyancePreference.self)
    try _v.visit(field: VTOFFSET.excludeCredentials.p, fieldName: "excludeCredentials", required: false, type: ForwardOffset<Vector<ForwardOffset<Auth_WebAuthn_PublicKeyCredentialDescriptor>, Auth_WebAuthn_PublicKeyCredentialDescriptor>>.self)
    try _v.visit(field: VTOFFSET.authenticatorSelection.p, fieldName: "authenticatorSelection", required: false, type: ForwardOffset<Auth_WebAuthn_AuthenticatorSelectionCriteria>.self)
    try _v.visit(field: VTOFFSET.extensions.p, fieldName: "extensions", required: false, type: ForwardOffset<Auth_WebAuthn_RequestRegistrationExtensions>.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_AuthenticatorAttestationResponse: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case clientData = 4
    case attestationObject = 6
    case transports = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasClientData: Bool { let o = _accessor.offset(VTOFFSET.clientData.v); return o == 0 ? false : true }
  public var clientDataCount: Int32 { let o = _accessor.offset(VTOFFSET.clientData.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func clientData(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.clientData.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var clientData: [UInt8] { return _accessor.getVector(at: VTOFFSET.clientData.v) ?? [] }
  public func mutate(clientData: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.clientData.v); return _accessor.directMutate(clientData, index: _accessor.vector(at: o) + index * 1) }
  public var hasAttestationObject: Bool { let o = _accessor.offset(VTOFFSET.attestationObject.v); return o == 0 ? false : true }
  public var attestationObjectCount: Int32 { let o = _accessor.offset(VTOFFSET.attestationObject.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func attestationObject(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.attestationObject.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var attestationObject: [UInt8] { return _accessor.getVector(at: VTOFFSET.attestationObject.v) ?? [] }
  public func mutate(attestationObject: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.attestationObject.v); return _accessor.directMutate(attestationObject, index: _accessor.vector(at: o) + index * 1) }
  public var hasTransports: Bool { let o = _accessor.offset(VTOFFSET.transports.v); return o == 0 ? false : true }
  public var transportsCount: Int32 { let o = _accessor.offset(VTOFFSET.transports.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func transports(at index: Int32) -> Auth_WebAuthn_AuthenticatorTransport? { let o = _accessor.offset(VTOFFSET.transports.v); return o == 0 ? Auth_WebAuthn_AuthenticatorTransport.usb : Auth_WebAuthn_AuthenticatorTransport(rawValue: _accessor.directRead(of: Int8.self, offset: _accessor.vector(at: o) + index * 1)) }
  public static func startAuthenticatorAttestationResponse(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(clientData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: clientData, at: VTOFFSET.clientData.p) }
  public static func addVectorOf(attestationObject: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: attestationObject, at: VTOFFSET.attestationObject.p) }
  public static func addVectorOf(transports: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transports, at: VTOFFSET.transports.p) }
  public static func endAuthenticatorAttestationResponse(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAuthenticatorAttestationResponse(
    _ fbb: inout FlatBufferBuilder,
    clientDataVectorOffset clientData: Offset = Offset(),
    attestationObjectVectorOffset attestationObject: Offset = Offset(),
    transportsVectorOffset transports: Offset = Offset()
  ) -> Offset {
    let __start = Auth_WebAuthn_AuthenticatorAttestationResponse.startAuthenticatorAttestationResponse(&fbb)
    Auth_WebAuthn_AuthenticatorAttestationResponse.addVectorOf(clientData: clientData, &fbb)
    Auth_WebAuthn_AuthenticatorAttestationResponse.addVectorOf(attestationObject: attestationObject, &fbb)
    Auth_WebAuthn_AuthenticatorAttestationResponse.addVectorOf(transports: transports, &fbb)
    return Auth_WebAuthn_AuthenticatorAttestationResponse.endAuthenticatorAttestationResponse(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.clientData.p, fieldName: "clientData", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.attestationObject.p, fieldName: "attestationObject", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.transports.p, fieldName: "transports", required: false, type: ForwardOffset<Vector<Auth_WebAuthn_AuthenticatorTransport, Auth_WebAuthn_AuthenticatorTransport>>.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_RegistrationExtensionsClientOutputs: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case appId = 4
    case credProps = 6
    case hmacSecret = 8
    case credProtect = 10
    case minPinLength = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var appId: Bool { let o = _accessor.offset(VTOFFSET.appId.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(appId: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.appId.v);  return _accessor.mutate(appId, index: o) }
  public var credProps: Bool { let o = _accessor.offset(VTOFFSET.credProps.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(credProps: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.credProps.v);  return _accessor.mutate(credProps, index: o) }
  public var hmacSecret: Bool { let o = _accessor.offset(VTOFFSET.hmacSecret.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(hmacSecret: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.hmacSecret.v);  return _accessor.mutate(hmacSecret, index: o) }
  public var credProtect: Auth_WebAuthn_CredentialProtectionPolicy { let o = _accessor.offset(VTOFFSET.credProtect.v); return o == 0 ? .userverificationoptional : Auth_WebAuthn_CredentialProtectionPolicy(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .userverificationoptional }
  @discardableResult public func mutate(credProtect: Auth_WebAuthn_CredentialProtectionPolicy) -> Bool {let o = _accessor.offset(VTOFFSET.credProtect.v);  return _accessor.mutate(credProtect.rawValue, index: o) }
  public var minPinLength: UInt32 { let o = _accessor.offset(VTOFFSET.minPinLength.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  @discardableResult public func mutate(minPinLength: UInt32) -> Bool {let o = _accessor.offset(VTOFFSET.minPinLength.v);  return _accessor.mutate(minPinLength, index: o) }
  public static func startRegistrationExtensionsClientOutputs(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(appId: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: appId, def: false,
   at: VTOFFSET.appId.p) }
  public static func add(credProps: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: credProps, def: false,
   at: VTOFFSET.credProps.p) }
  public static func add(hmacSecret: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hmacSecret, def: false,
   at: VTOFFSET.hmacSecret.p) }
  public static func add(credProtect: Auth_WebAuthn_CredentialProtectionPolicy, _ fbb: inout FlatBufferBuilder) { fbb.add(element: credProtect.rawValue, def: 0, at: VTOFFSET.credProtect.p) }
  public static func add(minPinLength: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minPinLength, def: 0, at: VTOFFSET.minPinLength.p) }
  public static func endRegistrationExtensionsClientOutputs(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRegistrationExtensionsClientOutputs(
    _ fbb: inout FlatBufferBuilder,
    appId: Bool = false,
    credProps: Bool = false,
    hmacSecret: Bool = false,
    credProtect: Auth_WebAuthn_CredentialProtectionPolicy = .userverificationoptional,
    minPinLength: UInt32 = 0
  ) -> Offset {
    let __start = Auth_WebAuthn_RegistrationExtensionsClientOutputs.startRegistrationExtensionsClientOutputs(&fbb)
    Auth_WebAuthn_RegistrationExtensionsClientOutputs.add(appId: appId, &fbb)
    Auth_WebAuthn_RegistrationExtensionsClientOutputs.add(credProps: credProps, &fbb)
    Auth_WebAuthn_RegistrationExtensionsClientOutputs.add(hmacSecret: hmacSecret, &fbb)
    Auth_WebAuthn_RegistrationExtensionsClientOutputs.add(credProtect: credProtect, &fbb)
    Auth_WebAuthn_RegistrationExtensionsClientOutputs.add(minPinLength: minPinLength, &fbb)
    return Auth_WebAuthn_RegistrationExtensionsClientOutputs.endRegistrationExtensionsClientOutputs(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.appId.p, fieldName: "appId", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.credProps.p, fieldName: "credProps", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.hmacSecret.p, fieldName: "hmacSecret", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.credProtect.p, fieldName: "credProtect", required: false, type: Auth_WebAuthn_CredentialProtectionPolicy.self)
    try _v.visit(field: VTOFFSET.minPinLength.p, fieldName: "minPinLength", required: false, type: UInt32.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_RegisterPublicKeyCredential: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case rawId = 6
    case response = 8
    case clientExtensionResults = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasId: Bool { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? false : true }
  public var idCount: Int32 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func id(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var id: [UInt8] { return _accessor.getVector(at: VTOFFSET.id.v) ?? [] }
  public func mutate(id: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.id.v); return _accessor.directMutate(id, index: _accessor.vector(at: o) + index * 1) }
  public var hasRawId: Bool { let o = _accessor.offset(VTOFFSET.rawId.v); return o == 0 ? false : true }
  public var rawIdCount: Int32 { let o = _accessor.offset(VTOFFSET.rawId.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func rawId(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.rawId.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var rawId: [UInt8] { return _accessor.getVector(at: VTOFFSET.rawId.v) ?? [] }
  public func mutate(rawId: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.rawId.v); return _accessor.directMutate(rawId, index: _accessor.vector(at: o) + index * 1) }
  public var response: Auth_WebAuthn_AuthenticatorAttestationResponse? { let o = _accessor.offset(VTOFFSET.response.v); return o == 0 ? nil : Auth_WebAuthn_AuthenticatorAttestationResponse(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var clientExtensionResults: Auth_WebAuthn_RegistrationExtensionsClientOutputs? { let o = _accessor.offset(VTOFFSET.clientExtensionResults.v); return o == 0 ? nil : Auth_WebAuthn_RegistrationExtensionsClientOutputs(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startRegisterPublicKeyCredential(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func addVectorOf(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func addVectorOf(rawId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rawId, at: VTOFFSET.rawId.p) }
  public static func add(response: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: response, at: VTOFFSET.response.p) }
  public static func add(clientExtensionResults: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: clientExtensionResults, at: VTOFFSET.clientExtensionResults.p) }
  public static func endRegisterPublicKeyCredential(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRegisterPublicKeyCredential(
    _ fbb: inout FlatBufferBuilder,
    idVectorOffset id: Offset = Offset(),
    rawIdVectorOffset rawId: Offset = Offset(),
    responseOffset response: Offset = Offset(),
    clientExtensionResultsOffset clientExtensionResults: Offset = Offset()
  ) -> Offset {
    let __start = Auth_WebAuthn_RegisterPublicKeyCredential.startRegisterPublicKeyCredential(&fbb)
    Auth_WebAuthn_RegisterPublicKeyCredential.addVectorOf(id: id, &fbb)
    Auth_WebAuthn_RegisterPublicKeyCredential.addVectorOf(rawId: rawId, &fbb)
    Auth_WebAuthn_RegisterPublicKeyCredential.add(response: response, &fbb)
    Auth_WebAuthn_RegisterPublicKeyCredential.add(clientExtensionResults: clientExtensionResults, &fbb)
    return Auth_WebAuthn_RegisterPublicKeyCredential.endRegisterPublicKeyCredential(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.rawId.p, fieldName: "rawId", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.response.p, fieldName: "response", required: false, type: ForwardOffset<Auth_WebAuthn_AuthenticatorAttestationResponse>.self)
    try _v.visit(field: VTOFFSET.clientExtensionResults.p, fieldName: "clientExtensionResults", required: false, type: ForwardOffset<Auth_WebAuthn_RegistrationExtensionsClientOutputs>.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_CredProtect: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case credentialProtectionPolicy = 4
    case enforceCredentialProtectionPolicy = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The credential policy to enact
  public var credentialProtectionPolicy: Auth_WebAuthn_CredentialProtectionPolicy { let o = _accessor.offset(VTOFFSET.credentialProtectionPolicy.v); return o == 0 ? .userverificationoptional : Auth_WebAuthn_CredentialProtectionPolicy(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .userverificationoptional }
  @discardableResult public func mutate(credentialProtectionPolicy: Auth_WebAuthn_CredentialProtectionPolicy) -> Bool {let o = _accessor.offset(VTOFFSET.credentialProtectionPolicy.v);  return _accessor.mutate(credentialProtectionPolicy.rawValue, index: o) }
  ///  Whether it is better for the authenticator to fail to create a
  ///  credential rather than ignore the protection policy
  public var enforceCredentialProtectionPolicy: Bool { let o = _accessor.offset(VTOFFSET.enforceCredentialProtectionPolicy.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(enforceCredentialProtectionPolicy: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.enforceCredentialProtectionPolicy.v);  return _accessor.mutate(enforceCredentialProtectionPolicy, index: o) }
  public static func startCredProtect(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(credentialProtectionPolicy: Auth_WebAuthn_CredentialProtectionPolicy, _ fbb: inout FlatBufferBuilder) { fbb.add(element: credentialProtectionPolicy.rawValue, def: 0, at: VTOFFSET.credentialProtectionPolicy.p) }
  public static func add(enforceCredentialProtectionPolicy: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: enforceCredentialProtectionPolicy, def: false,
   at: VTOFFSET.enforceCredentialProtectionPolicy.p) }
  public static func endCredProtect(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCredProtect(
    _ fbb: inout FlatBufferBuilder,
    credentialProtectionPolicy: Auth_WebAuthn_CredentialProtectionPolicy = .userverificationoptional,
    enforceCredentialProtectionPolicy: Bool = false
  ) -> Offset {
    let __start = Auth_WebAuthn_CredProtect.startCredProtect(&fbb)
    Auth_WebAuthn_CredProtect.add(credentialProtectionPolicy: credentialProtectionPolicy, &fbb)
    Auth_WebAuthn_CredProtect.add(enforceCredentialProtectionPolicy: enforceCredentialProtectionPolicy, &fbb)
    return Auth_WebAuthn_CredProtect.endCredProtect(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.credentialProtectionPolicy.p, fieldName: "credentialProtectionPolicy", required: false, type: Auth_WebAuthn_CredentialProtectionPolicy.self)
    try _v.visit(field: VTOFFSET.enforceCredentialProtectionPolicy.p, fieldName: "enforceCredentialProtectionPolicy", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_RequestRegistrationExtensions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case credProtect = 4
    case uvm = 6
    case credProps = 8
    case minPinLength = 10
    case hmacCreateSecret = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The `credProtect` extension options
  public var credProtect: Auth_WebAuthn_CredProtect? { let o = _accessor.offset(VTOFFSET.credProtect.v); return o == 0 ? nil : Auth_WebAuthn_CredProtect(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  ⚠️  - Browsers do not support this!
  public var uvm: Bool { let o = _accessor.offset(VTOFFSET.uvm.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(uvm: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.uvm.v);  return _accessor.mutate(uvm, index: o) }
  ///  ⚠️  - This extension result is always unsigned, and only indicates if the
  ///  browser *requests* a residentKey to be created. It has no bearing on the
  ///  true rk state of the credential.
  public var credProps: Bool { let o = _accessor.offset(VTOFFSET.credProps.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(credProps: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.credProps.v);  return _accessor.mutate(credProps, index: o) }
  ///  CTAP2.1 Minumum pin length
  public var minPinLength: Bool { let o = _accessor.offset(VTOFFSET.minPinLength.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(minPinLength: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.minPinLength.v);  return _accessor.mutate(minPinLength, index: o) }
  ///  ⚠️  - Browsers support the *creation* of the secret, but not the retrieval of it.
  ///  CTAP2.1 create hmac secret
  public var hmacCreateSecret: Bool { let o = _accessor.offset(VTOFFSET.hmacCreateSecret.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(hmacCreateSecret: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.hmacCreateSecret.v);  return _accessor.mutate(hmacCreateSecret, index: o) }
  public static func startRequestRegistrationExtensions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(credProtect: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: credProtect, at: VTOFFSET.credProtect.p) }
  public static func add(uvm: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: uvm, def: false,
   at: VTOFFSET.uvm.p) }
  public static func add(credProps: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: credProps, def: false,
   at: VTOFFSET.credProps.p) }
  public static func add(minPinLength: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: minPinLength, def: false,
   at: VTOFFSET.minPinLength.p) }
  public static func add(hmacCreateSecret: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hmacCreateSecret, def: false,
   at: VTOFFSET.hmacCreateSecret.p) }
  public static func endRequestRegistrationExtensions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRequestRegistrationExtensions(
    _ fbb: inout FlatBufferBuilder,
    credProtectOffset credProtect: Offset = Offset(),
    uvm: Bool = false,
    credProps: Bool = false,
    minPinLength: Bool = false,
    hmacCreateSecret: Bool = false
  ) -> Offset {
    let __start = Auth_WebAuthn_RequestRegistrationExtensions.startRequestRegistrationExtensions(&fbb)
    Auth_WebAuthn_RequestRegistrationExtensions.add(credProtect: credProtect, &fbb)
    Auth_WebAuthn_RequestRegistrationExtensions.add(uvm: uvm, &fbb)
    Auth_WebAuthn_RequestRegistrationExtensions.add(credProps: credProps, &fbb)
    Auth_WebAuthn_RequestRegistrationExtensions.add(minPinLength: minPinLength, &fbb)
    Auth_WebAuthn_RequestRegistrationExtensions.add(hmacCreateSecret: hmacCreateSecret, &fbb)
    return Auth_WebAuthn_RequestRegistrationExtensions.endRequestRegistrationExtensions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.credProtect.p, fieldName: "credProtect", required: false, type: ForwardOffset<Auth_WebAuthn_CredProtect>.self)
    try _v.visit(field: VTOFFSET.uvm.p, fieldName: "uvm", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.credProps.p, fieldName: "credProps", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.minPinLength.p, fieldName: "minPinLength", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.hmacCreateSecret.p, fieldName: "hmacCreateSecret", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_PublicKeyCredentialDescriptor: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case id = 6
    case transports = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The type of credential to exclude.
  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  ///  The credential ID to exclude.
  public var hasId: Bool { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? false : true }
  public var idCount: Int32 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func id(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var id: [UInt8] { return _accessor.getVector(at: VTOFFSET.id.v) ?? [] }
  public func mutate(id: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.id.v); return _accessor.directMutate(id, index: _accessor.vector(at: o) + index * 1) }
  ///  The transports that are allowed for this credential.
  public var hasTransports: Bool { let o = _accessor.offset(VTOFFSET.transports.v); return o == 0 ? false : true }
  public var transportsCount: Int32 { let o = _accessor.offset(VTOFFSET.transports.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func transports(at index: Int32) -> Auth_WebAuthn_AuthenticatorTransport? { let o = _accessor.offset(VTOFFSET.transports.v); return o == 0 ? Auth_WebAuthn_AuthenticatorTransport.usb : Auth_WebAuthn_AuthenticatorTransport(rawValue: _accessor.directRead(of: Int8.self, offset: _accessor.vector(at: o) + index * 1)) }
  public static func startPublicKeyCredentialDescriptor(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func addVectorOf(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func addVectorOf(transports: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: transports, at: VTOFFSET.transports.p) }
  public static func endPublicKeyCredentialDescriptor(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPublicKeyCredentialDescriptor(
    _ fbb: inout FlatBufferBuilder,
    typeOffset type: Offset = Offset(),
    idVectorOffset id: Offset = Offset(),
    transportsVectorOffset transports: Offset = Offset()
  ) -> Offset {
    let __start = Auth_WebAuthn_PublicKeyCredentialDescriptor.startPublicKeyCredentialDescriptor(&fbb)
    Auth_WebAuthn_PublicKeyCredentialDescriptor.add(type: type, &fbb)
    Auth_WebAuthn_PublicKeyCredentialDescriptor.addVectorOf(id: id, &fbb)
    Auth_WebAuthn_PublicKeyCredentialDescriptor.addVectorOf(transports: transports, &fbb)
    return Auth_WebAuthn_PublicKeyCredentialDescriptor.endPublicKeyCredentialDescriptor(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.transports.p, fieldName: "transports", required: false, type: ForwardOffset<Vector<Auth_WebAuthn_AuthenticatorTransport, Auth_WebAuthn_AuthenticatorTransport>>.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_AuthenticatorSelectionCriteria: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case authenticatorAttachment = 4
    case requireResidentKey = 6
    case userVerification = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The authenticator attachment mode.
  public var authenticatorAttachment: Auth_WebAuthn_AuthenticatorAttachment { let o = _accessor.offset(VTOFFSET.authenticatorAttachment.v); return o == 0 ? .platform : Auth_WebAuthn_AuthenticatorAttachment(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .platform }
  @discardableResult public func mutate(authenticatorAttachment: Auth_WebAuthn_AuthenticatorAttachment) -> Bool {let o = _accessor.offset(VTOFFSET.authenticatorAttachment.v);  return _accessor.mutate(authenticatorAttachment.rawValue, index: o) }
  ///  Whether or not the authenticator must be resident.
  public var requireResidentKey: Bool { let o = _accessor.offset(VTOFFSET.requireResidentKey.v); return o == 0 ? false : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  @discardableResult public func mutate(requireResidentKey: Byte) -> Bool {let o = _accessor.offset(VTOFFSET.requireResidentKey.v);  return _accessor.mutate(requireResidentKey, index: o) }
  ///  The list of authenticator transports that are allowed.
  public var userVerification: Auth_WebAuthn_UserVerificationPolicy { let o = _accessor.offset(VTOFFSET.userVerification.v); return o == 0 ? .preferred : Auth_WebAuthn_UserVerificationPolicy(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .preferred }
  @discardableResult public func mutate(userVerification: Auth_WebAuthn_UserVerificationPolicy) -> Bool {let o = _accessor.offset(VTOFFSET.userVerification.v);  return _accessor.mutate(userVerification.rawValue, index: o) }
  public static func startAuthenticatorSelectionCriteria(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(authenticatorAttachment: Auth_WebAuthn_AuthenticatorAttachment, _ fbb: inout FlatBufferBuilder) { fbb.add(element: authenticatorAttachment.rawValue, def: 0, at: VTOFFSET.authenticatorAttachment.p) }
  public static func add(requireResidentKey: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: requireResidentKey, def: false,
   at: VTOFFSET.requireResidentKey.p) }
  public static func add(userVerification: Auth_WebAuthn_UserVerificationPolicy, _ fbb: inout FlatBufferBuilder) { fbb.add(element: userVerification.rawValue, def: 0, at: VTOFFSET.userVerification.p) }
  public static func endAuthenticatorSelectionCriteria(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAuthenticatorSelectionCriteria(
    _ fbb: inout FlatBufferBuilder,
    authenticatorAttachment: Auth_WebAuthn_AuthenticatorAttachment = .platform,
    requireResidentKey: Bool = false,
    userVerification: Auth_WebAuthn_UserVerificationPolicy = .preferred
  ) -> Offset {
    let __start = Auth_WebAuthn_AuthenticatorSelectionCriteria.startAuthenticatorSelectionCriteria(&fbb)
    Auth_WebAuthn_AuthenticatorSelectionCriteria.add(authenticatorAttachment: authenticatorAttachment, &fbb)
    Auth_WebAuthn_AuthenticatorSelectionCriteria.add(requireResidentKey: requireResidentKey, &fbb)
    Auth_WebAuthn_AuthenticatorSelectionCriteria.add(userVerification: userVerification, &fbb)
    return Auth_WebAuthn_AuthenticatorSelectionCriteria.endAuthenticatorSelectionCriteria(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.authenticatorAttachment.p, fieldName: "authenticatorAttachment", required: false, type: Auth_WebAuthn_AuthenticatorAttachment.self)
    try _v.visit(field: VTOFFSET.requireResidentKey.p, fieldName: "requireResidentKey", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.userVerification.p, fieldName: "userVerification", required: false, type: Auth_WebAuthn_UserVerificationPolicy.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_PubKeyCredParams: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case type = 4
    case alg = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var type: String? { let o = _accessor.offset(VTOFFSET.type.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var typeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.type.v) }
  public var alg: Int32 { let o = _accessor.offset(VTOFFSET.alg.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  @discardableResult public func mutate(alg: Int32) -> Bool {let o = _accessor.offset(VTOFFSET.alg.v);  return _accessor.mutate(alg, index: o) }
  public static func startPubKeyCredParams(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(type: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: type, at: VTOFFSET.type.p) }
  public static func add(alg: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: alg, def: 0, at: VTOFFSET.alg.p) }
  public static func endPubKeyCredParams(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPubKeyCredParams(
    _ fbb: inout FlatBufferBuilder,
    typeOffset type: Offset = Offset(),
    alg: Int32 = 0
  ) -> Offset {
    let __start = Auth_WebAuthn_PubKeyCredParams.startPubKeyCredParams(&fbb)
    Auth_WebAuthn_PubKeyCredParams.add(type: type, &fbb)
    Auth_WebAuthn_PubKeyCredParams.add(alg: alg, &fbb)
    return Auth_WebAuthn_PubKeyCredParams.endPubKeyCredParams(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.type.p, fieldName: "type", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.alg.p, fieldName: "alg", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_RelyingParty: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case name = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public static func startRelyingParty(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func endRelyingParty(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRelyingParty(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    nameOffset name: Offset = Offset()
  ) -> Offset {
    let __start = Auth_WebAuthn_RelyingParty.startRelyingParty(&fbb)
    Auth_WebAuthn_RelyingParty.add(id: id, &fbb)
    Auth_WebAuthn_RelyingParty.add(name: name, &fbb)
    return Auth_WebAuthn_RelyingParty.endRelyingParty(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Auth_WebAuthn_User: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_4() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case name = 6
    case displayName = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  The user's base58 encoded, 32 byte user ID.
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  The user's name.
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  ///  The user's display name. Defaults to the user's name.
  public var displayName: String? { let o = _accessor.offset(VTOFFSET.displayName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var displayNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.displayName.v) }
  public static func startUser(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(displayName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: displayName, at: VTOFFSET.displayName.p) }
  public static func endUser(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUser(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    displayNameOffset displayName: Offset = Offset()
  ) -> Offset {
    let __start = Auth_WebAuthn_User.startUser(&fbb)
    Auth_WebAuthn_User.add(id: id, &fbb)
    Auth_WebAuthn_User.add(name: name, &fbb)
    Auth_WebAuthn_User.add(displayName: displayName, &fbb)
    return Auth_WebAuthn_User.endUser(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.displayName.p, fieldName: "displayName", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

